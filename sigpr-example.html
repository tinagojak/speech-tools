<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Edinburgh Speech Tools: Example of Signal Processing code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="est.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Edinburgh Speech Tools
   &#160;<span id="projectnumber">2.1-release</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sigpr-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Example of Signal Processing code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#producing-feature-vector-for-utt">Producing a single type of feature vector for an utterance</a></li>
<li class="level1"><a href="#pitchvsfixframe">Pitch-Synchronous vs fixed frame analysis.</a></li>
<li class="level1"><a href="#sigpr-example-naming-channels">Naming Channels</a></li>
<li class="level1"><a href="#sigpr-deltaacc">Producing delta and acceleration coefficients</a></li>
<li class="level1"><a href="#sigpr-windowing">Windowing</a></li>
<li class="level1"><a href="#sigpr-example-frames">Frame based signal processing</a></li>
<li class="level1"><a href="#sigpr-filtering">Filtering</a></li>
</ul>
</div>
<div class="textblock"><p>Signal processing examples <h1><a class="anchor" id="producing-feature-vector-for-utt"></a>
Producing a single type of feature vector for an utterance</h1>
<p>A number of types of signal processing can be performed by the <a class="el" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a> function. The following code demonstrates a simple case of calculating the linear prediction (LP) coefficients for a waveform.</p>
<p>First set the order of the lpc analysis to 16 (this entails 17 actual coefficients) and then load in the waveform to be analysed.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    </div><div class="line">    <span class="keywordtype">int</span> lpc_order = 16;</div><div class="line">    sig.<a class="code" href="classEST__Wave.html#a7ddc30992b9e968b16f3fd8d07f71097">load</a>(DATA <span class="stringliteral">&quot;/kdt_001.wav&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Now allocate enough space in the track to hold the analysis. The following command resizes <code>fv</code> to have enough frames for analysis frames at 0.01 intervals up to the end of the waveform, (sig.end()), and enough channels to store <code>lpc_order + 1</code> coefficients. The channels are named so as to take lpc coefficients.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <span class="keywordtype">int</span> num_frames;</div><div class="line">    num_frames = (<a class="code" href="EST__item__aux_8cc.html#a1df5fe11f53c95af603b87dfb85ec653">int</a>)ceil(sig.<a class="code" href="classEST__Wave.html#ae7d04503524f4c5b37d975a58ba68ffb">end</a>() / 0.01);</div><div class="line">    fv.resize(num_frames, lpc_order + 1);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The positions of the frames, corresponding to the middle of their analysis window also need to be set. For fixed frame analysis, this can be done with the <a class="el" href="classEST__Track.html#ad9c8a2d32cf0a2936ae475ba3a945d03">EST_Track::fill_time()</a> function:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.fill_time(0.01);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The simplest way to do the actual analysis is as follows, which will fill the track with the values from the LP analysis using the default processing controls.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, fv, <span class="stringliteral">&quot;lpc&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>In this style of analysis, default values are used to control the windowing mechanisms which split the whole signal into frames.</p>
<p>Specifically, each frame is defined to start a certain distance before the time interval, and extending the same distance after. This distance is calculated as a function of the local window spacing and can be adjusted as follows:</p>
<p>Extending one time period before and one time period after the current time mark:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, fv, <span class="stringliteral">&quot;lpc&quot;</span>, 2.0);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Extending 1.5 time periods before and after the current time mark, etc;</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, fv, <span class="stringliteral">&quot;lpc&quot;</span>, 3.0);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The type of windowing function may be changed also as this can be passed in as an optional argument. First we create a window function (This is explained more in Windowing).</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Function.html#ga4d65ccb7d060e363d584a7b425f1ebd2">EST_WindowFunc</a> *wf =  <a class="code" href="classEST__Window.html#ac99eccb9c15ebea25f2aeec9fa4901c3">EST_Window::creator</a>(<span class="stringliteral">&quot;hamming&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --> and then pass it in as the last argument</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, fv, <span class="stringliteral">&quot;lpc&quot;</span>, 3.0, wf);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<h1><a class="anchor" id="pitchvsfixframe"></a>
Pitch-Synchronous vs fixed frame analysis.</h1>
<p>Most of the core signal processing functions operate on individual frames of speech and are oblivious as to how these frames were extracted from the original speech. This allows us to take the frames from anywhere in the signal: specifically, this facilitates two common forms of analysis:</p>
<ul>
<li><b>fixed frame</b>: The time points are space at even intervals throughout the signal.</li>
<li><b>pitch-synchronous</b>: The time points represent <em>pitchmarks</em> and correspond to a specific position in each pitch period, e.g. the instant of glottal closure.</li>
</ul>
<p>It is a simple matter to fill the time array, but normally pitchmarks are read from a file or taken from another signal processing algorithm (see "Pitchmark functions").</p>
<p>There are many ways to fill the time array for fixed frame analysis.</p>
<p>manually:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    num_frames = 300;</div><div class="line">    fv.resize(num_frames, lpc_order + 1);</div><div class="line">    shift = 0.01; <span class="comment">// time interval in seconds</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; num_frames; ++i)</div><div class="line">    fv.t(i) = shift * (float) i;</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>or by use of the member function <a class="el" href="classEST__Track.html#ad9c8a2d32cf0a2936ae475ba3a945d03">EST_Track::fill_time</a></p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.fill_time(0.01);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Pitch synchronous values can simply be read from pitchmark files:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.load(DATA <span class="stringliteral">&quot;/kdt_001.pm&quot;</span>);</div><div class="line">    make_track(fv, <span class="stringliteral">&quot;lpc&quot;</span>, lpc_order + 1);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Regardless of how the time points where obtain, the analysis function call is just the same:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, fv, <span class="stringliteral">&quot;lpc&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<h1><a class="anchor" id="sigpr-example-naming-channels"></a>
Naming Channels</h1>
<p>Multiple types of feature vector can be stored in the same Track. Imagine that we want lpc, cepstrum and power coefficients in that order in a track. This can be achieved by using the <a class="el" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a> function multiple times, or by the wrap around <a class="el" href="group__Functionsforusewithframebasedprocessing.html#ga77566998ee9fdf2655bc1e4a8c47eae7">sigpr_base</a> function.</p>
<p>It is vitally important here to ensure that before passing the track to the signal processing functions that it has the correct number of channels and that these are appropriately named. This is most easily done using the track map facility, explained in <a class="el" href="EST_Track-example.html#est_trac_naming_channels">Naming Channels</a>.</p>
<p>For each call, we only us the part of track that is relevant. The <a class="el" href="classEST__Track.html#a8cd00db6b78d956b6db85113e208e7a0">EST_Track::sub_track</a> member function is used to get this. In the following example, we are assuming here that <code>fv</code> has sufficient space for 17 lpc coefficients, 8 cepstrum coefficients and power and that they are stored in that order.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> cep_order = 16;</div><div class="line">    <a class="code" href="classEST__TList.html">EST_StrList</a> map;</div><div class="line"></div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$lpc-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(lpc_order));</div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$cepc-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(cep_order));</div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;power&quot;</span>);</div><div class="line"></div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>An alternative is to use <a class="el" href="sig2fv__main_8cc.html#a4da4faf40e3fd5ef2c58ec09b7769570">add_channels_to_map()</a> which takes a list of coefficient types and makes a map. The order of each type of processing is extracted from op.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    <a class="code" href="classEST__TList.html">EST_StrList</a> coef_types;</div><div class="line"></div><div class="line">    coef_types.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;lpc&quot;</span>);</div><div class="line">    coef_types.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;cep&quot;</span>);</div><div class="line">    coef_types.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;power&quot;</span>);</div><div class="line"></div><div class="line">    map.<a class="code" href="classEST__TList.html#a3dac6678c648eb208e3bd492c48e56ce">clear</a>();</div><div class="line"></div><div class="line">    <a class="code" href="sig2fv__main_8cc.html#a4da4faf40e3fd5ef2c58ec09b7769570">add_channels_to_map</a>(map, coef_types, op);</div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map);</div><div class="line"></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>After allocating the right number of frames and channels in <code>fv</code>, we extract a sub_track, which has all the frames (i.e. between 0 and EST_ALL) and all the lpc channels.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.sub_track(part, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, 0, <span class="stringliteral">&quot;lpc_0&quot;</span>, <span class="stringliteral">&quot;lpc_N&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>now call the signal processing function on this part:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, part, <span class="stringliteral">&quot;lpc&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>We repeat the procedure for the cepstral coefficients, but this time take the next 8 channels (17-24 inclusive) and calculate the coefficients:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.sub_track(part, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, <span class="stringliteral">&quot;cep_0&quot;</span>, <span class="stringliteral">&quot;cep_N&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, part, <span class="stringliteral">&quot;cep&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Extract the last channel for power and call the power function:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.sub_track(part, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, <span class="stringliteral">&quot;power&quot;</span>, 1);</div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#ga4445c0e873965dc0344d58ae0c3195aa">power</a>(sig, part, 0.01);</div><div class="line"></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>While the above technique is adequate for our needs and is a useful demonstration of sub_track extraction, the <a class="el" href="group__Functionsforusewithframebasedprocessing.html#ga77566998ee9fdf2655bc1e4a8c47eae7">sigpr_base</a> function is normally easier to use as it does all the sub track extraction itself. To perform the lpc, cepstrum and power analysis, we put these names into a EST_StrList and call <a class="el" href="group__Functionsforusewithframebasedprocessing.html#ga77566998ee9fdf2655bc1e4a8c47eae7">sigpr_base</a>.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    base_list.clear(); <span class="comment">// empty the list, just in case</span></div><div class="line">    base_list.append(<span class="stringliteral">&quot;lpc&quot;</span>);</div><div class="line">    base_list.append(<span class="stringliteral">&quot;cep&quot;</span>);</div><div class="line">    base_list.append(<span class="stringliteral">&quot;power&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#ga77566998ee9fdf2655bc1e4a8c47eae7">sigpr_base</a>(sig, fv, op, base_list);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>This will call sigpr_track as many times as is necessary.</p>
<h1><a class="anchor" id="sigpr-deltaacc"></a>
Producing delta and acceleration coefficients</h1>
<p>Delta coefficients represent the numerical differentiation of a track, and acceleration coefficients represent the second order numerical differentiation.</p>
<p>By convention, delta coefficients have a "_d" suffix and acceleration coefficients "_a". If the coefficient is multi-dimensional, the numbers go after the "_d" or "_a".</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$cep_d-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(cep_order)); <span class="comment">// add deltas</span></div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$cep_a-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(cep_order)); <span class="comment">// add accs</span></div><div class="line"></div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map); <span class="comment">// resize the track.</span></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Given a <a class="el" href="classEST__Track.html">EST_Track</a> of coefficients <code>fv</code>, the <a class="el" href="pitchmark_8cc.html#a553af12e31dfdb40f414673e924dc0e0">EST_Track::delta</a> function is used to produce the delta equivalents <code>del</code>. The following uses the track allocated above and generates a set of cepstral coefficients and then makes their delta and acc:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    <a class="code" href="classEST__Track.html">EST_Track</a> del, acc;</div><div class="line"></div><div class="line">    fv.<a class="code" href="classEST__Track.html#a8cd00db6b78d956b6db85113e208e7a0">sub_track</a>(part, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, 0, <span class="stringliteral">&quot;cep_0&quot;</span>, <span class="stringliteral">&quot;cep_N&quot;</span>); <span class="comment">// make subtrack of coefs</span></div><div class="line">    <a class="code" href="group__Functionsforusewithframebasedprocessing.html#gaa030f43671e9262f612851eb5885b957">sig2coef</a>(sig, part, <span class="stringliteral">&quot;cep&quot;</span>);  <span class="comment">// fill with cepstra</span></div><div class="line"></div><div class="line">    <span class="comment">// make subtrack of deltas</span></div><div class="line">    fv.sub_track(del, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, 0, <span class="stringliteral">&quot;cep_d_0&quot;</span>, <span class="stringliteral">&quot;cep_d_N&quot;</span>); </div><div class="line">    <a class="code" href="group__DeltaandAccelerationcoefficients.html#ga42d364648047af61bfbdf00f17bc3352">delta</a>(part, del);  <span class="comment">// calculate deltas of part, and place answer in del</span></div><div class="line"></div><div class="line">    <span class="comment">// make subtrack of accs</span></div><div class="line">    fv.sub_track(acc, 0, <a class="code" href="EST__matrix__support_8cc.html#ae0e0794f05426f5bbe78228f746cc4b3">EST_ALL</a>, 0, <span class="stringliteral">&quot;cep_a_0&quot;</span>, <span class="stringliteral">&quot;cep_a_N&quot;</span>); </div><div class="line">    <a class="code" href="group__DeltaandAccelerationcoefficients.html#ga42d364648047af61bfbdf00f17bc3352">delta</a>(del, acc);  <span class="comment">// calculate deltas of del, and place answer in acc</span></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>It is possible to directly calculate the delta coefficients of a type of coefficient, even if we don't have the base type. <a class="el" href="sigpr__utt_8cc.html#ac2b1583b9bea19a67d7472ddd85903a0">sigpr_delta</a> will process the waveform, make a temporary track of the required type "lpc" and calculate the delta of this.</p>
<p>The following makes a set of delta reflection coefficients:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$ref_d-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(lpc_order)); <span class="comment">// add to map </span></div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map); <span class="comment">// resize the track.</span></div><div class="line"></div><div class="line">    <a class="code" href="group__DeltaandAccelerationcoefficients.html#ga0e8fb8ee2c67fec0df01945a116aac1d">sigpr_delta</a>(sig, fv, op, <span class="stringliteral">&quot;ref&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>an equivalent function exists for acceleration coefficients:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$lsf_a-0+&quot;</span> <a class="code" href="group__utilityfunctionsforstrings.html#ga16229e503093541fc3aa0f51e13d92a3">Stringtoi</a>(lpc_order)); <span class="comment">// add acc lsf</span></div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map); <span class="comment">// resize the track.</span></div><div class="line"></div><div class="line">    <a class="code" href="group__DeltaandAccelerationcoefficients.html#ga31d358d0157c94d62dc1399709e8e05d">sigpr_acc</a>(sig, fv, op, <span class="stringliteral">&quot;ref&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<h1><a class="anchor" id="sigpr-windowing"></a>
Windowing</h1>
<p>The <a class="el" href="classEST__Window.html">EST_Window</a> class provides a variety of means to divide speech into frames using windowing mechanisms.</p>
<p>A window function can be created from a window name using the <a class="el" href="classEST__Window.html#ac99eccb9c15ebea25f2aeec9fa4901c3" title="Return the creation function for the given window type. ">EST_Window::creator</a> function:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    <a class="code" href="group__Function.html#ga4d65ccb7d060e363d584a7b425f1ebd2">EST_WindowFunc</a> *hamm =  <a class="code" href="classEST__Window.html#ac99eccb9c15ebea25f2aeec9fa4901c3">EST_Window::creator</a>(<span class="stringliteral">&quot;hamming&quot;</span>);</div><div class="line">    <a class="code" href="group__Function.html#ga4d65ccb7d060e363d584a7b425f1ebd2">EST_WindowFunc</a> *rect =  <a class="code" href="classEST__Window.html#ac99eccb9c15ebea25f2aeec9fa4901c3">EST_Window::creator</a>(<span class="stringliteral">&quot;rectangular&quot;</span>);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>This function can then be used to create a <a class="el" href="classEST__TBuffer.html" title="Extending buffer class. ">EST_TBuffer</a> of window values. In the following example the values from a 256 point hamming window are stored in the buffer <code>win_vals</code>:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__FVector.html">EST_FVector</a> frame;</div><div class="line">    <a class="code" href="classEST__FVector.html">EST_FVector</a> win_vals;</div><div class="line"></div><div class="line">    hamm(256, win_vals);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The make_window function also creates a window:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__Window.html#aa60f0e64fed3d9d16527e0b08b2167ec">EST_Window::make_window</a>(win_vals, 256, <span class="stringliteral">&quot;hamming&quot;</span>,-1);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>this can then be used to make a frame of speech from the main <a class="el" href="classEST__Wave.html" title="A class for storing digital waveforms. The waveform is stored as an array of 16 bit shorts...">EST_Wave</a> <code>sig</code>. The following example extracts speech starting at sample 1000:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; 256; ++i)</div><div class="line">    frame[i] = (<span class="keywordtype">float</span>)sig.<a class="code" href="classEST__Wave.html#a49fdc815e671662d2acdb5828b30b3ed">a</a>(i + 1000) * win_vals[i];</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Alternatively, exactly the same operation can be performed in a single step by passing the window function to the <a class="el" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a> function which takes a <a class="el" href="classEST__Wave.html" title="A class for storing digital waveforms. The waveform is stored as an array of 16 bit shorts...">EST_Wave</a> and performs windowing on a section of it, storing the output in the <a class="el" href="classEST__FVector.html" title="A vector class for floating point numbers. EST_FVector x should be used instead of float *x wherever ...">EST_FVector</a> <code>frame</code>.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a>(sig, hamm, 1000, 256, frame, 1);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The window function need not be explicitly created, the window signal can work on just the name of the window type:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a>(sig, <span class="stringliteral">&quot;hamming&quot;</span>, 1000, 256, frame, 1);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<h1><a class="anchor" id="sigpr-example-frames"></a>
Frame based signal processing</h1>
<p>The signal processing library provides an extensive set of functions which operate on a single frame of coefficients. The following example shows one method of splitting the signal into frames and calling a signal processing algorithm.</p>
<p>First set up the track for 16 order LP analysis:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    map.<a class="code" href="classEST__TList.html#a3dac6678c648eb208e3bd492c48e56ce">clear</a>();</div><div class="line">    map.<a class="code" href="classEST__TList.html#a4796ddc854ff93fd7f86acd86b9e21a1">append</a>(<span class="stringliteral">&quot;$lpc-0+16&quot;</span>);</div><div class="line">    </div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map);</div><div class="line"></div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>In this example, we take the analysis frame length to be 256 samples long, and the shift in samples is just the shift in seconds times the sampling frequency.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <span class="keywordtype">int</span> s_length = 256;</div><div class="line">    <span class="keywordtype">int</span> s_shift =  <a class="code" href="EST__item__aux_8cc.html#a1df5fe11f53c95af603b87dfb85ec653">int</a>(shift * <span class="keywordtype">float</span>(sig.<a class="code" href="classEST__Wave.html#ada84e2aeaa593131c40818e09d5d99f1">sample_rate</a>()));</div><div class="line">    <a class="code" href="classEST__FVector.html">EST_FVector</a> coefs;</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Now we set up a loop which calculates the frames one at a time. <code>start</code> is the start position in samples of each frame. The <a class="el" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a> function is called which makes a <a class="el" href="classEST__FVector.html" title="A vector class for floating point numbers. EST_FVector x should be used instead of float *x wherever ...">EST_FVector</a> frame of the speech via a hamming window.</p>
<p>Using the <a class="el" href="classEST__Track.html#af0a76a2a8cda0fc9ba03b2d2ae9452c3">EST_Track::frame</a> function, the <a class="el" href="classEST__FVector.html" title="A vector class for floating point numbers. EST_FVector x should be used instead of float *x wherever ...">EST_FVector</a> <code>coefs</code> is set to frame <code>k</code> in the track. It is important to understand that this operation involves setting an internal smart pointer in <code>coefs</code> to the memory of frame <code>k</code>. This allows the signal processing function <a class="el" href="group__LinearPredictionfunctions.html#gac0c36181f1d9e21991133b26401a5146">sig2lpc</a> to operate on an input and output <a class="el" href="classEST__FVector.html" title="A vector class for floating point numbers. EST_FVector x should be used instead of float *x wherever ...">EST_FVector</a>, without any copying to or from the main track. After the <a class="el" href="group__LinearPredictionfunctions.html#gac0c36181f1d9e21991133b26401a5146">sig2lpc</a> call, the kth frame of <code>fv</code> is now filled with the LP coefficients.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k1 = 0; k1 &lt; fv.num_frames(); ++k1)</div><div class="line">    {</div><div class="line">    <span class="keywordtype">int</span> start = (k1 * s_shift) - (s_length/2);</div><div class="line">    <a class="code" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a>(sig, <span class="stringliteral">&quot;hamming&quot;</span>, start, s_length, frame, 1);</div><div class="line"></div><div class="line">    fv.frame(coefs, k1);    <span class="comment">// Extract a single frame</span></div><div class="line">    <a class="code" href="group__LinearPredictionfunctions.html#ga7c3fbf7ca0191b6f188b9d15eb99c7ee">sig2lpc</a>(frame, coefs);  <span class="comment">// Pass this to actual algorithm</span></div><div class="line">    }</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>A slightly different tack can be taken for pitch-synchronous analysis. Setting up fv with the pitchmarks and channels:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    fv.load(DATA <span class="stringliteral">&quot;/kd1_001.pm&quot;</span>);</div><div class="line">    fv.resize(<a class="code" href="EST__matrix__support_8cc.html#a2dc6b243e1fd87e0132c5e381af9a93e">EST_CURRENT</a>, map);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Set up as before, but this time calculate the window starts and lengths from the time points. In this example, the length is a <code>factor</code> (twice) the local frame shift. Note that the only difference between this function and the fixed frame one is in the calculation of the start and end points - the</p>
<p>windowing, frame extraction and call to <a class="el" href="group__LinearPredictionfunctions.html#gac0c36181f1d9e21991133b26401a5146">sig2lpc</a> are exactly the same.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <span class="keywordtype">float</span> factor = 2.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k2 = 0; k2 &lt; fv.num_frames(); ++k2)</div><div class="line">    {</div><div class="line">    s_length = irint(<a class="code" href="group__EST__Track__aux__functions.html#gaa43fd7ea55c73fe086305dccb047006d">get_frame_size</a>(fv, k2, sig.<a class="code" href="classEST__Wave.html#ada84e2aeaa593131c40818e09d5d99f1">sample_rate</a>())* factor);</div><div class="line">    <span class="keywordtype">int</span> start = (irint(fv.t(k2) * sig.<a class="code" href="classEST__Wave.html#ada84e2aeaa593131c40818e09d5d99f1">sample_rate</a>()) - (s_length/2));</div><div class="line"></div><div class="line">    <a class="code" href="classEST__Window.html#a9c458ca7818a7c36cf536489a3b668d8">EST_Window::window_signal</a>(sig, wf, start, s_length, frame, 1);</div><div class="line"></div><div class="line">    fv.frame(coefs, k2);</div><div class="line">    <a class="code" href="group__LinearPredictionfunctions.html#ga7c3fbf7ca0191b6f188b9d15eb99c7ee">sig2lpc</a>(frame, coefs);</div><div class="line">    }</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<h1><a class="anchor" id="sigpr-filtering"></a>
Filtering</h1>
<p>In the EST library we so far have two main types of filter, finite impulse response (FIR)** filters and <b>linear prediction (LP)</b> filters. <b>infinite impulse response (IIR)</b> filters are not yet implemented, though LP filters are a special case of these.</p>
<p>Filtering involves 2 stages: the design of the filter and the use of this filter on the waveform.</p>
<p>First we examine a simple low-pass filter which attempts to suppress all frequencies about a cut-off. Imagine we want to low pass filter a signal at 400Hz. First we design the filter:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line"></div><div class="line">    <a class="code" href="classEST__FVector.html">EST_FVector</a> filter;</div><div class="line">    <span class="keywordtype">int</span> freq = 400;</div><div class="line">    <span class="keywordtype">int</span> filter_order = 99;</div><div class="line"></div><div class="line">    filter = <a class="code" href="group__FilterDesign.html#ga413ac25afc2eef8d9382a4c508012089">design_lowpass_FIR_filter</a>(sig.<a class="code" href="classEST__Wave.html#ada84e2aeaa593131c40818e09d5d99f1">sample_rate</a>(), 400, 99);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>And now use this filter on the signal:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__FIRfilters.html#gaf1de5da124c13d973ae2e73107b5a1c4">FIRfilter</a>(sig, filter);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>For one-off filtering operations, the filter design can be done in the filter function itself. The <a class="el" href="group__FIRfilters.html#ga0cf09f6633ba0b8e578fadc2bf5bd84d">FIRlowpass_filter</a> function takes the signal, cut-off frequency and order as arguments and designs the filter on the fly. Because of the overhead of filter design, this function is expensive and should only be used for one-off operations.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__FIRfilters.html#ga0cf09f6633ba0b8e578fadc2bf5bd84d">FIRlowpass_filter</a>(sig, 400, 99);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The equivalent operations exist for high-pass filtering:</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    filter = <a class="code" href="group__FilterDesign.html#ga0e6b2d0bf174fdc27506d0aa31b2c07c">design_highpass_FIR_filter</a>(sig.<a class="code" href="classEST__Wave.html#ada84e2aeaa593131c40818e09d5d99f1">sample_rate</a>(), 50, 99);</div><div class="line">    <a class="code" href="group__FIRfilters.html#gaf1de5da124c13d973ae2e73107b5a1c4">FIRfilter</a>(sig, filter);</div><div class="line">    <a class="code" href="group__FIRfilters.html#ga5e83e682724dec958c0803833c28a844">FIRhighpass_filter</a>(sig, 50, 99);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Filters of arbitrary frequency response can also be designed using the <a class="el" href="group__FilterDesign.html#ga032399891e7562bbff60a6b62cc27348">design_FIR_filter</a> function. This function takes a <a class="el" href="classEST__FVector.html" title="A vector class for floating point numbers. EST_FVector x should be used instead of float *x wherever ...">EST_FVector</a> of order <img class="formulaInl" alt="$2^{N}$" src="form_50.png"/> which specifies the desired frequency response up to 1/2 the sampling frequency. The function returns a set of filter coefficients that attempt to match the desired reponse.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__FVector.html">EST_FVector</a> response(16);</div><div class="line">    response[0] = 1;</div><div class="line">    response[1] = 1;</div><div class="line">    response[2] = 1;</div><div class="line">    response[3] = 1;</div><div class="line">    response[4] = 0;</div><div class="line">    response[5] = 0;</div><div class="line">    response[6] = 0;</div><div class="line">    response[7] = 0;</div><div class="line">    response[8] = 1;</div><div class="line">    response[9] = 1;</div><div class="line">    response[10] = 1;</div><div class="line">    response[11] = 1;</div><div class="line">    response[12] = 0;</div><div class="line">    response[13] = 0;</div><div class="line">    response[14] = 0;</div><div class="line">    response[15] = 0;</div><div class="line"></div><div class="line">    filter = <a class="code" href="group__FilterDesign.html#ga032399891e7562bbff60a6b62cc27348">design_FIR_filter</a>(response, 15);</div><div class="line"></div><div class="line">    <a class="code" href="group__FIRfilters.html#gaf1de5da124c13d973ae2e73107b5a1c4">FIRfilter</a>(sig, response);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>The normal filtering functions can cause a time delay in the filtered waveform. To attempt to eliminate this, a set of double filter function functions are provided which guarantees zero phase differences between the original and filtered waveform.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="group__FIRfilters.html#ga50b7df940e6d6d07e98834c019e86a39">FIRlowpass_double_filter</a>(sig, 400);</div><div class="line">    <a class="code" href="group__FIRfilters.html#ga2090fe66456ec4603f93b8b2b2be8472">FIRhighpass_double_filter</a>(sig, 40);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --></p>
<p>Sometimes it is undesirable to have the input signal overwritten. For these cases, a set of parallel functions exist which take a input waveform for reading and a output waveform for writing to.</p>
<p><div class="fragment"><div class="line">    <span class="comment">///@ code</span></div><div class="line">    <a class="code" href="classEST__Wave.html">EST_Wave</a> sig_out;</div><div class="line"></div><div class="line">    <a class="code" href="group__FIRfilters.html#gaf1de5da124c13d973ae2e73107b5a1c4">FIRfilter</a>(sig, sig_out, response);</div><div class="line">    <a class="code" href="group__FIRfilters.html#ga0cf09f6633ba0b8e578fadc2bf5bd84d">FIRlowpass_filter</a>(sig, sig_out, 400);</div><div class="line">    <a class="code" href="group__FIRfilters.html#ga5e83e682724dec958c0803833c28a844">FIRhighpass_filter</a>(sig, sig_out, 40);</div><div class="line">    <span class="comment">///@ endcode</span></div></div><!-- fragment --> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 6 2017 18:25:31 for Edinburgh Speech Tools by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
